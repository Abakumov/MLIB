function s_seismic4jason(seismic,varargin)
% Function writes seismic data to ASCII file in Jason, comma-separated format.
% Written by: E. Rietsch: February 14, 2004
% Last updated: October 11, 2005: bug fix with file name
%
%           s_seismic4jason(wavelet,varargin)
% INPUT
% wavelet   seismic in form of a seismic structure
% varargin  one or more cell arrays; the first element of each cell array is a keyword,
%           the other elements are parameters. Presently, keywords are:
%     'filename'  name of the data set written to file (used in the descriptive
%           header of the file generated),
%           Default: {'filename',seismic.name}
%     'format'  floating point format used for the trace data.
%           Default: {'format','10.6g'}
%     'generated_by'  string with in formation regarding the program that 
%           generated the data (used in the descriptive header of the 
%           file generated),
%           Default: {'generated_by','SeisLab'}
%     'separator'  separator between numbers,; most popular are 'tab' and 'comma'
%           but others, such as ' ' are also possible.
%           Default: {'separator','tab')

global ABORTED S4M

%	Set defaults
param.separator='tab';
param.generated_by=S4M.name;
param.filename=seismic.name;
param.format='%10.6f';

%	Modify defaults by input arguments
param=assign_input(param,varargin);

%	Remove null values and leading/trailing zeros
seismic=s_rm_zeros(s_rm_trace_nulls(seismic));

[nsamp,ntr]=size(seismic.traces);

n1=15;
text=cell(n1+3,1);

text(1:n1) = {...
['* Jason export format using "',param.separator,'"-separated values']; 
['* Multitrace export generated by ',param.generated_by]; 
['* Export date: ',S4M.time]; 
['* Generated from data set: ',seismic.name]; 
'*'; 
'* File format: '; 
'* - N lines starting with * are comment (such as this line)'; 
'* - 1 line with four fields (data type, data unit, depth type, depth unit)'; 
'* - 1 line with start time/depth'; 
'* - 1 line with sample interval'; 
'* - 1 line with number of data traces'; 
'* - N lines with trace data '; 
'* Data values are represented as floating point numbers,'; 
'* except for lithology data, which are represented as strings'; 
'wavelet,none,time,ms'};


units=seismic.units;

if strcmp(units,'ms') || strcmp(units,'s')
   depth_type='time';
elseif strcmp(units,'m') || strcmp(units,'ft')
   depth_type='depth';
else
   depth_type='unknown';
end

text{n1}=['"',seismic.tag,'","none","',depth_type,'","',units,'"'];
text{n1+1}=num2str(seismic.first);
text{n1+2}=num2str(seismic.step);
text{n1+3}=num2str(nsamp);


if isempty(findstr(param.filename,filesep))  &&  isempty(findstr(param.filename,':'))
%	If the path is not fully qualified ask for a file name
%   name=seismic.name;
%   [dummy,filename,ext]=fileparts(seismic.name)%test
%   filename=[deblank(param.filename),'.txt'];
   fid=-1;
else
   fid=fopen(param.filename,'wt');
end

newline = sprintf('\n');

%	Create delimiter
if strcmp(param.separator,'comma')
   dlm=',';
elseif strcmp(param.separator,'tab')
   dlm=sprintf('\t');
   text{n1}=['"wavelet"',dlm,'"none"',dlm,'"time"',dlm,'"ms"'];
else
   dlm=param.separator;
end

%  	Open the file
if fid == -1 
   param.filename=get_filename4w('.txt',param.filename);
   if ABORTED
      return
   end
end

fid=fopen(param.filename,'wt');

	try
for ii=1:length(text)
   % fprintf(fid,[text{ii},'\n']);
   fprintf(fid,[text{ii},newline]);
end

%	Start writing the array, for now number format float
for ii = 1:nsamp
    for jj = 1:ntr
    %    str = num2str(seismic.traces(ii,jj),param.format);
	fprintf(fid,param.format,seismic.traces(ii,jj));
    %    fprintf(fid, str, 'uchar');      
        if(jj < ntr)
            fprintf(fid, dlm, 'uchar');    
        end
    end
    fwrite(fid, newline, 'char');
end

%	Close file
fclose(fid);
ABORTED=false;	% Execution successful

	catch

fclose(fid)
ABORTED=true;	% Execution failed
	end
